import { getSession } from "next-auth/react";
import { getToken, JWT } from "next-auth/jwt";

import Head from "next/head";
import styled from "styled-components";
import { PollsItemType } from "../polls";
import PollHeader from "../../components/poll/poll_header";
import { GetServerSideProps } from "next";
import PollsItem from "../../components/polls/polls_item";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faPlus } from "@fortawesome/free-solid-svg-icons";
import { ChangeEvent, useState } from "react";
import ErrorModal from "../../components/utils/error_modal";
import SuccessModal from "../../components/utils/success_modal";
import LoadingModal from "../../components/utils/loading_modal";

interface PollProps {
  questionInfo: PollsItemType;
  answersInfo: Array<PollsItemType>;
}

const PollDiv = styled.div`
  max-width: 800px;
`;

const ResponseDiv = styled.div`
  display: flex;
  flex-direction: row;
  align-content: center;
  align-items: center;
  flex-wrap: wrap;

  padding: 0.75rem 0.75rem;
  padding-right: 0px;
`;

const FileAndTextDiv = styled.div`
  display: flex;
  flex-direction: column;
  flex: 90%;
  margin-right: 10px;
`;

export default function Poll({ questionInfo, answersInfo }: PollProps) {
  const [answer, setAnswer] = useState<{ textValue: string; mediaValue: File }>(
    { textValue: "", mediaValue: {} as File }
  );
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const changeAnswer = (
    changeType: string,
    event: ChangeEvent<HTMLInputElement>
  ) => {
    let newAnswer = { textValue: "", mediaValue: new File([], "") };
    if (changeType == "text") {
      newAnswer = {
        textValue: event.target.value,
        mediaValue: answer.mediaValue,
      };
    } else if (changeType == "media") {
      if (event.target.files)
        newAnswer = {
          textValue: answer.textValue,
          mediaValue: event.target.files[0],
        };
    }
    setAnswer(newAnswer);
  };

  const createNewAnswer = async () => {
    if (answer.textValue === "" && answer.mediaValue.name === "") {
      return;
    }

    const payload = {
      text: answer.textValue,
      media_bits: "",
      total_bytes: 0,
      media_type: "",
      conversation_id: questionInfo.id,
    };

    if (answer.mediaValue.name !== undefined) {
      const bits = await answer.mediaValue.arrayBuffer();
      const bits_b64 = Buffer.from(bits).toString("base64");
      payload.media_bits = bits_b64;
      payload.total_bytes = answer.mediaValue.size;
      payload.media_type = answer.mediaValue.type;
    }

    setIsLoading(true);
    let response = await fetch("/api/twitter/create_answer", {
      method: "POST",
      body: JSON.stringify(payload),
    });
    setIsLoading(false);

    if (response.status !== 200) {
      // An error occured
      setErrorMessage(
        "Aconteceu um erro ao criar a resposta. Por favor tente novamente."
      );
    } else {
      // Poll created with success
      setSuccessMessage("A sua resposta foi criada com sucesso!");
    }
  };

  return (
    <>
      <Head>
        <title>PollMaster - Poll</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <PollHeader pollInfo={questionInfo} />

      <PollDiv className="container px-4 col-sm-12 col-md-12 col-lg-8 col-xl-7 ">
        {answersInfo.map(function (answerInfo: PollsItemType, index) {
          return (
            <PollsItem
              key={index}
              pollInfo={answerInfo}
              liked={answerInfo.liked}
              retweeted={answerInfo.retweeted}
              show_link={false}
              media_url={answerInfo.media_url}
              media_type={answerInfo.media_type}
            ></PollsItem>
          );
        })}

        <ResponseDiv className="form-control">
          <h4>Nova resposta</h4>
          <FileAndTextDiv>
            <input
              type="text"
              className="form-control"
              placeholder="Inserir PossÃ­vel Resposta"
              onChange={(event) => changeAnswer("text", event)}
            />

            <hr />

            <label htmlFor={"customFile"}>Opcional</label>
            <input
              type="file"
              className="form-control"
              id={"customFile"}
              onChange={(event) => changeAnswer("media", event)}
            />

            <div className="my-3 d-flex justify-content-center">
              <FontAwesomeIcon
                className="fs-5 primary-text rounded-full secondary-bg p-3"
                style={{ borderRadius: "100%" }}
                icon={faPlus}
                onClick={() => createNewAnswer()}
              />
            </div>
          </FileAndTextDiv>
        </ResponseDiv>
      </PollDiv>

      <ErrorModal
        show={errorMessage !== ""}
        onHide={() => setErrorMessage("")}
        message={errorMessage}
      />
      <SuccessModal
        show={successMessage !== ""}
        onHide={() => setSuccessMessage("")}
        message={successMessage}
      />
      {isLoading && <LoadingModal />}
    </>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const poll_id = context.query.id;

  const question_tweet_request = await fetch(
    "https://api.twitter.com/2/tweets/" +
      poll_id +
      "?tweet.fields=author_id,attachments,public_metrics,created_at,in_reply_to_user_id",
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization:
          "Bearer AAAAAAAAAAAAAAAAAAAAAC44lAEAAAAASyImn8TyZNNTx8yk8lMxSYyv6J8%3D51pNo3D8QCOpHLTZF8sm9NSfJD2RQgcYt1FXHpeg3tKQpGRZkL",
      },
    }
  );

  let questionData = await question_tweet_request.json();

  const answers_tweet_request = await fetch(
    "https://api.twitter.com/2/tweets/search/recent?tweet.fields=author_id,attachments,public_metrics,created_at,in_reply_to_user_id&query=conversation_id:" +
      poll_id,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization:
          "Bearer AAAAAAAAAAAAAAAAAAAAAC44lAEAAAAASyImn8TyZNNTx8yk8lMxSYyv6J8%3D51pNo3D8QCOpHLTZF8sm9NSfJD2RQgcYt1FXHpeg3tKQpGRZkL",
      },
    }
  );

  const answersData = await answers_tweet_request.json();
  let answers = [];

  const session = await getSession(context);

  for (const element of answersData.data) {
    let item = element;
    const answer_tweet_request = await fetch(
      "https://api.twitter.com/1.1/statuses/show.json?id=" +
        item.id +
        "&tweet.fields=author_id,attachments,public_metrics,created_at,in_reply_to_user_id",
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization:
            "Bearer AAAAAAAAAAAAAAAAAAAAAC44lAEAAAAASyImn8TyZNNTx8yk8lMxSYyv6J8%3D51pNo3D8QCOpHLTZF8sm9NSfJD2RQgcYt1FXHpeg3tKQpGRZkL",
        },
      }
    );

    if (answer_tweet_request.status !== 200) {
      continue;
    }

    const answer_tweet_res = await answer_tweet_request.json();
    let media_url = "";
    let media_type = "";
    if (answer_tweet_res.extended_entities) {
      media_type = answer_tweet_res.extended_entities.media[0].type;
      if (media_type === "photo") {
        media_url = answer_tweet_res.extended_entities.media[0].media_url;
      } else if (media_type === "video") {
        media_url =
          answer_tweet_res.extended_entities.media[0].video_info.variants.filter(
            (e: { content_type: string }) => e.content_type === "video/mp4"
          )[0].url;
      }
    }

    if (session?.user !== null) {
      // User is authenticated
      const results = await checkTweetLikeandRetweet(item, context);
      answers.push({
        ...item,
        liked: results.liked,
        retweeted: results.retweeted,
        media_url: media_url,
        media_type: media_type,
      });
    } else {
      answers.push({
        ...item,
        liked: false,
        retweeted: false,
        media_url: media_url,
        media_type: media_type,
      });
    }
  }

  if (session?.user !== null) {
    // User is authenticated
    const results = await checkTweetLikeandRetweet(questionData.data, context);
    questionData.data.liked = results.liked;
    questionData.data.retweeted = results.retweeted;
  } else {
    questionData.data.liked = false;
    questionData.data.retweeted = false;
  }

  return {
    props: {
      questionInfo: questionData.data,
      answersInfo: answers,
    },
  };
};

const checkTweetLikeandRetweet = async (item: any, context: any) => {
  const session = await getSession(context);

  const req = context.req;
  let tokenInfo: JWT | null;
  if (session?.user) {
    tokenInfo = await getToken({
      req,
      secret: process.env.NEXTAUTH_SECRET,
    });
  }

  let liked = false;
  let retweeted = false;
  // Get list of likes
  const tweet_likes = await fetch(
    "https://api.twitter.com/2/tweets/" + item.id + "/liking_users",
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization:
          "Bearer AAAAAAAAAAAAAAAAAAAAAC44lAEAAAAASyImn8TyZNNTx8yk8lMxSYyv6J8%3D51pNo3D8QCOpHLTZF8sm9NSfJD2RQgcYt1FXHpeg3tKQpGRZkL",
      },
    }
  ).then((res) => res.json());
  if (
    tweet_likes.data !== undefined &&
    tweet_likes.data.some((e: { id: any }) => e.id === tokenInfo?.account_id)
  ) {
    liked = true;
  }

  // Get list of retweets
  const retweets = await fetch(
    "https://api.twitter.com/2/tweets/" + item.id + "/retweeted_by",
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization:
          "Bearer AAAAAAAAAAAAAAAAAAAAAC44lAEAAAAASyImn8TyZNNTx8yk8lMxSYyv6J8%3D51pNo3D8QCOpHLTZF8sm9NSfJD2RQgcYt1FXHpeg3tKQpGRZkL",
      },
    }
  ).then((res) => res.json());
  if (
    retweets.data !== undefined &&
    retweets.data.some((e: { id: any }) => e.id === tokenInfo?.account_id)
  ) {
    retweeted = true;
  }

  return { liked: liked, retweeted: retweeted };
};
